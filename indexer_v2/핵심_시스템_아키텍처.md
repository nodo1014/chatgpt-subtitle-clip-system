# ğŸ—ï¸ Theme Search - í•µì‹¬ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

> **ğŸ¯ ì„ ì„ ê°œë°œìë¥¼ ìœ„í•œ ê¸°ìˆ ì  ìƒì„¸ ê°€ì´ë“œ**

## ğŸ“‹ ëª©ì°¨
1. [ì‹œìŠ¤í…œ ê°œìš”](#ì‹œìŠ¤í…œ-ê°œìš”)
2. [í•µì‹¬ ë¡œì§ ë¶„ì„](#í•µì‹¬-ë¡œì§-ë¶„ì„)
3. [ë°ì´í„° í”Œë¡œìš°](#ë°ì´í„°-í”Œë¡œìš°)
4. [API ì•„í‚¤í…ì²˜](#api-ì•„í‚¤í…ì²˜)
5. [ë³´ì•ˆ ì‹œìŠ¤í…œ](#ë³´ì•ˆ-ì‹œìŠ¤í…œ)
6. [ì„±ëŠ¥ ìµœì í™”](#ì„±ëŠ¥-ìµœì í™”)
7. [í™•ì¥ ê°€ëŠ¥ì„±](#í™•ì¥-ê°€ëŠ¥ì„±)

---

## ğŸ›ï¸ ì‹œìŠ¤í…œ ê°œìš”

### ê¸°ìˆ  ìŠ¤íƒ
```typescript
Frontend: Next.js 15.3.3 + TypeScript + Tailwind CSS
Backend: Next.js API Routes (Server-side)
Database: SQLite (better-sqlite3) + FTS (Full-Text Search)
Video: FFmpeg (í´ë¦½ ìƒì„± ë° ì¸ë„¤ì¼)
Deployment: Vercel (í”„ë¡ íŠ¸ì—”ë“œ) + Node.js (ë°±ì—”ë“œ)
```

### ì•„í‚¤í…ì²˜ íŒ¨í„´
- **í’€ìŠ¤íƒ ëª¨ë…¸ë¦¬ìŠ¤**: Next.jsë¡œ í”„ë¡ íŠ¸ì—”ë“œì™€ ë°±ì—”ë“œ í†µí•©
- **RESTful API**: ëª…í™•í•œ ì—”ë“œí¬ì¸íŠ¸ êµ¬ì¡°
- **íŒŒì¼ ê¸°ë°˜ ë¼ìš°íŒ…**: Next.js App Router í™œìš©
- **ì„œë²„ì‚¬ì´ë“œ ë Œë”ë§**: ê²€ìƒ‰ ê²°ê³¼ í˜ì´ì§€ ìµœì í™”

---

## ğŸ”§ í•µì‹¬ ë¡œì§ ë¶„ì„

### 1. ğŸ” ê²€ìƒ‰ ì—”ì§„ (`batch-search/route.ts`)

#### ì˜ì–´ ë¬¸ì¥ ì¶”ì¶œ ë¡œì§
```typescript
function extractEnglishSentences(text: string): string[] {
  // 1. í•œê¸€/ì¤‘êµ­ì–´/ì¼ë³¸ì–´ ë¬¸ì ì œê±°
  const koreanRegex = /[\u1100-\u11FF\u3130-\u318F\uAC00-\uD7AF\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF]/g;
  
  // 2. ì¤„ë°”ê¿ˆ ê¸°ì¤€ ë¶„ë¦¬ + í•„í„°ë§
  const lines = text.split('\n').map(line => line.trim()).filter(line => {
    if (line.length === 0) return false;
    if (koreanRegex.test(line)) return false;
    if (line.length < 3) return false;
    if (line.split(/\s+/).length < 2) return false;
    return true;
  });
  
  return lines;
}
```

#### SQLite FTS ê²€ìƒ‰ ìµœì í™”
```typescript
function searchInDatabase(query: string, limit: number): SearchResult[] {
  try {
    // Primary: FTS5 ê²€ìƒ‰ (ì„±ëŠ¥ ìš°ì„ )
    const stmt = database.prepare(`
      SELECT s.media_file, s.text, s.start_time, s.end_time, s.language, s.directory,
             rank
      FROM subtitles_fts fts
      JOIN subtitles s ON s.id = fts.rowid
      WHERE fts.text MATCH ?
      ORDER BY rank
      LIMIT ?
    `);
    
    const results = stmt.all(query, limit);
    return results.map((row: any, index: number) => ({
      // ...ë§¤í•‘ ë¡œì§
      confidence: Math.max(0.7, Math.min(1.0, 1.0 - (index * 0.05)))
    }));

  } catch (error) {
    // Fallback: LIKE ê²€ìƒ‰
    const stmt = database.prepare(`
      SELECT media_file, text, start_time, end_time, language, directory
      FROM subtitles 
      WHERE text LIKE ? COLLATE NOCASE
      ORDER BY media_file, start_time
      LIMIT ?
    `);
    
    return stmt.all(`%${query}%`, limit);
  }
}
```

### 2. ğŸ¬ í´ë¦½ ìƒì„± íŒŒì´í”„ë¼ì¸ (`auto-clips/route.ts`)

#### 3ë‹¨ê³„ ë°°ì¹˜ ì²˜ë¦¬
```typescript
// ë‹¨ê³„ 1: JSON ë©”íƒ€ë°ì´í„° ìƒì„±
async function createMetadataFiles(clips: ClipRequest[]): Promise<void> {
  for (const clip of clips) {
    const metadata = {
      id: generateUniqueId(),
      title: clip.title,
      sentence: clip.sentence,
      // ...ê¸°íƒ€ ë©”íƒ€ë°ì´í„°
    };
    
    await fs.writeFile(
      path.join(clipsDir, `${metadata.id}.json`),
      JSON.stringify(metadata, null, 2)
    );
  }
}

// ë‹¨ê³„ 2: ì¸ë„¤ì¼ ìƒì„± (FFmpeg)
async function generateThumbnails(clips: ClipRequest[]): Promise<void> {
  const commands = clips.map(clip => {
    const timeSeconds = parseTimeToSeconds(clip.startTime) + 1; // 1ì´ˆ í›„ ìº¡ì²˜
    return `ffmpeg -i "${clip.sourceFile}" -ss ${timeSeconds} ` +
           `-vf "scale=320:180,brightness=${brightness},contrast=${contrast}" ` +
           `-q:v ${quality} -frames:v 1 "${clip.thumbnailPath}"`;
  });
  
  await Promise.allSettled(commands.map(cmd => exec(cmd)));
}

// ë‹¨ê³„ 3: ë¹„ë””ì˜¤ í´ë¦½ ìƒì„± (FFmpeg)
async function generateVideoClips(clips: ClipRequest[]): Promise<void> {
  const commands = clips.map(clip => {
    const startTime = adjustTime(clip.startTime, -paddingSeconds);
    const duration = calculateDuration(clip.startTime, clip.endTime, paddingSeconds);
    
    return `ffmpeg -i "${clip.sourceFile}" -ss ${startTime} -t ${duration} ` +
           `-c:v ${videoCodec} -c:a ${audioCodec} -avoid_negative_ts make_zero ` +
           `"${clip.outputPath}"`;
  });
  
  await Promise.allSettled(commands.map(cmd => exec(cmd)));
}
```

### 3. âš™ï¸ ì•ˆì „í•œ ì„¤ì • ê´€ë¦¬ (`config-manager.ts`)

#### ê³„ì¸µì  ì„¤ì • ì‹œìŠ¤í…œ
```typescript
// ê¸°ë³¸ ì„¤ì • (ì½”ë“œ ë ˆë²¨)
const DEFAULT_CONFIG = {
  mediaConfig: { /* ê¸°ë³¸ê°’ë“¤ */ },
  searchConfig: { /* ê¸°ë³¸ê°’ë“¤ */ }
};

// ì‚¬ìš©ì ì„¤ì • (íŒŒì¼ ë ˆë²¨)
const USER_SETTINGS_PATH = 'config/user-settings.json';

// ìµœì¢… ë³‘í•©ëœ ì„¤ì •
function getConfig(): Config {
  const userSettings = loadUserSettings();
  return deepMerge(DEFAULT_CONFIG, userSettings);
}
```

#### ì„¤ì • ê²€ì¦ ë° ì•ˆì „ì¥ì¹˜
```typescript
function validateConfigStructure(config: any): boolean {
  // 1. êµ¬ì¡° ê²€ì¦
  if (!config.mediaConfig || !config.searchConfig) {
    return false;
  }

  // 2. ê°’ ë²”ìœ„ ê²€ì¦
  const ffmpeg = config.mediaConfig.FFMPEG_SETTINGS;
  if (ffmpeg.THUMBNAIL_QUALITY < 1 || ffmpeg.THUMBNAIL_QUALITY > 5) {
    return false;
  }

  // 3. íƒ€ì… ê²€ì¦
  for (const [key, expectedType] of Object.entries(CONFIG_SCHEMA)) {
    if (typeof config[key] !== expectedType) {
      return false;
    }
  }

  return true;
}

function createBackup(): boolean {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = `${USER_SETTINGS_PATH}.backup.${timestamp}`;
    fs.copyFileSync(USER_SETTINGS_PATH, backupPath);
    return true;
  } catch (error) {
    return false;
  }
}
```

---

## ğŸŒŠ ë°ì´í„° í”Œë¡œìš°

### ê²€ìƒ‰ ìš”ì²­ í”Œë¡œìš°
```mermaid
graph TD
    A[ì‚¬ìš©ì ì…ë ¥] --> B[ì˜ì–´ ë¬¸ì¥ ì¶”ì¶œ]
    B --> C[FTS ê²€ìƒ‰ ì‹¤í–‰]
    C --> D[ê²°ê³¼ ì‹ ë¢°ë„ ê³„ì‚°]
    D --> E[JSON ì‘ë‹µ ìƒì„±]
    E --> F[í”„ë¡ íŠ¸ì—”ë“œ ë Œë”ë§]
    
    C --> G[Fallback LIKE ê²€ìƒ‰]
    G --> D
```

### í´ë¦½ ìƒì„± í”Œë¡œìš°
```mermaid
graph TD
    A[ê²€ìƒ‰ ê²°ê³¼] --> B[í´ë¦½ ìš”ì²­ ìƒì„±]
    B --> C[1ë‹¨ê³„: JSON ë©”íƒ€ë°ì´í„°]
    C --> D[2ë‹¨ê³„: ì¸ë„¤ì¼ ìƒì„±]
    D --> E[3ë‹¨ê³„: ë¹„ë””ì˜¤ í´ë¦½]
    E --> F[ì§„í–‰ìƒí™© ì—…ë°ì´íŠ¸]
    F --> G[í´ë¦½ ëª©ë¡ ìƒˆë¡œê³ ì¹¨]
```

### ì„¤ì • ê´€ë¦¬ í”Œë¡œìš°
```mermaid
graph TD
    A[ì„¤ì • ìš”ì²­] --> B[ì ê¸ˆ ìƒíƒœ í™•ì¸]
    B --> C{ì ê¹€?}
    C -->|Yes| D[ì¸ì¦ ìš”êµ¬]
    C -->|No| E[ì„¤ì • ë¡œë“œ]
    D --> F[ê´€ë¦¬ì í‚¤ ê²€ì¦]
    F --> G{ì¸ì¦ ì„±ê³µ?}
    G -->|Yes| E
    G -->|No| H[ì ‘ê·¼ ê±°ë¶€]
    E --> I[ê²€ì¦ ë° ë°±ì—…]
    I --> J[ì„¤ì • ì €ì¥]
```

---

## ğŸ”Œ API ì•„í‚¤í…ì²˜

### ì—”ë“œí¬ì¸íŠ¸ êµ¬ì¡°
```typescript
/api/
â”œâ”€â”€ batch-search/        # POST: ë‹¤ì¤‘ ë¬¸ì¥ ê²€ìƒ‰
â”‚   â””â”€â”€ route.ts
â”œâ”€â”€ auto-clips/          # POST: ìë™ í´ë¦½ ìƒì„±
â”‚   â””â”€â”€ route.ts  
â”œâ”€â”€ clips/              # GET: í´ë¦½ ëª©ë¡, POST: ë‹¨ì¼ í´ë¦½ ìƒì„±
â”‚   â”œâ”€â”€ route.ts
â”‚   â””â”€â”€ [id]/
â”‚       â””â”€â”€ route.ts     # DELETE: í´ë¦½ ì‚­ì œ
â””â”€â”€ settings/           # GET/POST/PUT/PATCH: ì„¤ì • ê´€ë¦¬
    â””â”€â”€ route.ts
```

### API ì‘ë‹µ íŒ¨í„´
```typescript
// ì„±ê³µ ì‘ë‹µ
interface SuccessResponse<T> {
  success: true;
  data: T;
  message?: string;
}

// ì‹¤íŒ¨ ì‘ë‹µ
interface ErrorResponse {
  success: false;
  error: string;
  code?: string;
}

// ê²€ìƒ‰ ì‘ë‹µ
interface SearchResponse {
  success: true;
  extracted_sentences: string[];
  search_summary: {
    total_sentences: number;
    total_results: number;
    average_per_sentence: string;
    search_time: number;
  };
  sentence_results: SentenceResult[];
  auto_create_clips: boolean;
}
```

### ì—ëŸ¬ í•¸ë“¤ë§ íŒ¨í„´
```typescript
try {
  // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
  const result = await processRequest(data);
  return NextResponse.json({ success: true, data: result });
  
} catch (error) {
  console.error('API ì˜¤ë¥˜:', error);
  
  if (error instanceof ValidationError) {
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 400 }
    );
  }
  
  return NextResponse.json(
    { success: false, error: 'ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜' },
    { status: 500 }
  );
}
```

---

## ğŸ” ë³´ì•ˆ ì‹œìŠ¤í…œ

### AI ë°©ì§€ ì„¤ì • ì ê¸ˆ
```typescript
// ì ê¸ˆ íŒŒì¼ ê¸°ë°˜ ë³´ì•ˆ
const LOCK_FILE = '.settings.lock';

function isSettingsLocked(): boolean {
  return fs.existsSync(LOCK_FILE);
}

function lockSettings(): void {
  fs.writeFileSync(LOCK_FILE, new Date().toISOString());
}

function unlockSettings(adminKey: string): boolean {
  if (adminKey !== process.env.ADMIN_UNLOCK_KEY) {
    return false;
  }
  
  try {
    fs.unlinkSync(LOCK_FILE);
    return true;
  } catch {
    return false;
  }
}
```

### ì…ë ¥ ê²€ì¦ ë° ìƒˆë‹ˆíƒ€ì´ì œì´ì…˜
```typescript
function sanitizeInput(input: string): string {
  return input
    .replace(/[<>\"']/g, '') // XSS ë°©ì§€
    .replace(/\0/g, '')      // NULL ë°”ì´íŠ¸ ì œê±°
    .trim()
    .substring(0, 1000);     // ê¸¸ì´ ì œí•œ
}

function validateSearchQuery(query: string): boolean {
  if (!query || query.length < 2) return false;
  if (query.length > 1000) return false;
  if (/[<>\"']/.test(query)) return false;
  return true;
}
```

### íŒŒì¼ ê²½ë¡œ ë³´ì•ˆ
```typescript
function sanitizePath(userPath: string): string {
  return path.resolve(
    path.join(SAFE_ROOT_DIR, path.normalize(userPath))
  ).replace(/\.\./g, ''); // ë””ë ‰í† ë¦¬ íŠ¸ë˜ë²„ì„¤ ë°©ì§€
}
```

---

## âš¡ ì„±ëŠ¥ ìµœì í™”

### ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”
```sql
-- FTS5 ì¸ë±ìŠ¤ í™œìš©
CREATE VIRTUAL TABLE subtitles_fts USING fts5(
  text,
  content='subtitles',
  content_rowid='id'
);

-- ë³µí•© ì¸ë±ìŠ¤
CREATE INDEX idx_media_time ON subtitles(media_file, start_time);
CREATE INDEX idx_language ON subtitles(language);
```

### í´ë¦½ ìƒì„± ìµœì í™”
```typescript
// ë°°ì¹˜ ì²˜ë¦¬ë¡œ FFmpeg í˜¸ì¶œ ìµœì†Œí™”
const BATCH_SIZE = 20;

async function processBatch<T>(
  items: T[],
  processor: (batch: T[]) => Promise<void>
): Promise<void> {
  for (let i = 0; i < items.length; i += BATCH_SIZE) {
    const batch = items.slice(i, i + BATCH_SIZE);
    await processor(batch);
  }
}
```

### í”„ë¡ íŠ¸ì—”ë“œ ìµœì í™”
```typescript
// 1. ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (í´ë¦½ ìƒì„± ì§„í–‰ìƒí™©)
useEffect(() => {
  const interval = setInterval(() => {
    if (autoClipProgress.isCreating) {
      loadClips(); // 2ì´ˆë§ˆë‹¤ ìƒˆë¡œê³ ì¹¨
    }
  }, 2000);
  
  return () => clearInterval(interval);
}, [autoClipProgress.isCreating]);

// 2. ì¡°ê±´ë¶€ ë Œë”ë§ (ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€)
const ClipCard = memo(({ clip }: { clip: ClipMetadata }) => {
  return <div>{/* í´ë¦½ UI */}</div>;
});

// 3. ì§€ì—° ë¡œë”© (í´ë¦½ ëª©ë¡)
const [clips, setClips] = useState<ClipMetadata[]>([]);
const [isLoading, setIsLoading] = useState(false);
```

---

## ğŸ”§ í™•ì¥ ê°€ëŠ¥ì„±

### 1. ë‹¤ì¤‘ ë°ì´í„°ë² ì´ìŠ¤ ì§€ì›
```typescript
interface DatabaseAdapter {
  search(query: string, limit: number): Promise<SearchResult[]>;
  connect(): Promise<void>;
  disconnect(): Promise<void>;
}

class SQLiteAdapter implements DatabaseAdapter {
  // SQLite êµ¬í˜„
}

class PostgreSQLAdapter implements DatabaseAdapter {
  // PostgreSQL êµ¬í˜„
}
```

### 2. í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ
```typescript
interface ClipProcessor {
  process(clip: ClipRequest): Promise<ProcessedClip>;
  supports(format: string): boolean;
}

class FFmpegProcessor implements ClipProcessor {
  // FFmpeg ê¸°ë°˜ ì²˜ë¦¬
}

class WebAssemblyProcessor implements ClipProcessor {
  // ë¸Œë¼ìš°ì € ê¸°ë°˜ ì²˜ë¦¬
}
```

### 3. ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ë¶„ë¦¬
```typescript
// í˜„ì¬: ëª¨ë…¸ë¦¬ìŠ¤
app/api/batch-search/route.ts
app/api/auto-clips/route.ts

// ë¯¸ë˜: ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤
search-service/
â”œâ”€â”€ src/
â”œâ”€â”€ Dockerfile
â””â”€â”€ package.json

clip-service/
â”œâ”€â”€ src/
â”œâ”€â”€ Dockerfile
â””â”€â”€ package.json
```

### 4. ìºì‹± ì‹œìŠ¤í…œ
```typescript
// Redis ìºì‹± (í–¥í›„)
interface CacheService {
  get(key: string): Promise<any>;
  set(key: string, value: any, ttl?: number): Promise<void>;
  del(key: string): Promise<void>;
}

// ê²€ìƒ‰ ê²°ê³¼ ìºì‹±
const cacheKey = `search:${hashQuery(query)}`;
const cached = await cache.get(cacheKey);
if (cached) {
  return cached;
}

const results = await searchDatabase(query);
await cache.set(cacheKey, results, 300); // 5ë¶„ ìºì‹œ
```

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (Jest)
```typescript
describe('extractEnglishSentences', () => {
  test('should extract valid English sentences', () => {
    const input = 'Hello world\nì•ˆë…•í•˜ì„¸ìš”\nHow are you?';
    const result = extractEnglishSentences(input);
    expect(result).toEqual(['Hello world', 'How are you?']);
  });
});

describe('validateConfigStructure', () => {
  test('should validate correct config structure', () => {
    const config = { mediaConfig: {}, searchConfig: {} };
    expect(validateConfigStructure(config)).toBe(true);
  });
});
```

### í†µí•© í…ŒìŠ¤íŠ¸
```typescript
describe('Batch Search API', () => {
  test('should return search results', async () => {
    const response = await fetch('/api/batch-search', {
      method: 'POST',
      body: JSON.stringify({ text: 'Hello world', results_per_sentence: 5 })
    });
    
    const data = await response.json();
    expect(data.success).toBe(true);
    expect(data.sentence_results).toBeDefined();
  });
});
```

### E2E í…ŒìŠ¤íŠ¸ (Playwright)
```typescript
test('complete search and clip creation flow', async ({ page }) => {
  await page.goto('/');
  await page.fill('[data-testid="search-input"]', 'Hello world');
  await page.click('[data-testid="search-button"]');
  
  await expect(page.locator('[data-testid="results"]')).toBeVisible();
  await page.click('[data-testid="create-clip"]');
  
  await expect(page.locator('[data-testid="clip-created"]')).toBeVisible();
});
```

---

## ğŸš€ ë°°í¬ ë° DevOps

### Docker ì»¨í…Œì´ë„ˆí™”
```dockerfile
FROM node:18-alpine

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 3000
CMD ["npm", "start"]
```

### í™˜ê²½ë³„ ì„¤ì •
```typescript
// development
const config = {
  database: 'public/working_subtitles.db',
  media_path: '/mnt/qnap/media_eng',
  log_level: 'debug'
};

// production
const config = {
  database: process.env.DATABASE_URL,
  media_path: process.env.MEDIA_PATH,
  log_level: 'info'
};
```

### ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…
```typescript
// êµ¬ì¡°í™”ëœ ë¡œê¹…
const logger = {
  info: (message: string, meta?: object) => {
    console.log(JSON.stringify({
      level: 'info',
      message,
      timestamp: new Date().toISOString(),
      ...meta
    }));
  },
  
  error: (message: string, error?: Error, meta?: object) => {
    console.error(JSON.stringify({
      level: 'error',
      message,
      error: error?.stack,
      timestamp: new Date().toISOString(),
      ...meta
    }));
  }
};
```

---

## ğŸ“Š ì„±ëŠ¥ ë©”íŠ¸ë¦­

### í•µì‹¬ ì§€í‘œ
- **ê²€ìƒ‰ ì‘ë‹µ ì‹œê°„**: < 500ms (FTS ê¸°ì¤€)
- **í´ë¦½ ìƒì„± ì‹œê°„**: í‰ê·  3ì´ˆ/í´ë¦½ (FFmpeg)
- **ë™ì‹œ ì‚¬ìš©ì**: ìµœëŒ€ 10ëª… (í˜„ì¬ êµ¬ì¡°)
- **ì €ì¥ì†Œ íš¨ìœ¨**: í´ë¦½ë‹¹ í‰ê·  2MB

### ë³‘ëª© ì§€ì 
1. **FFmpeg ì²˜ë¦¬**: CPU ì§‘ì•½ì  ì‘ì—…
2. **íŒŒì¼ I/O**: ëŒ€ìš©ëŸ‰ ë¹„ë””ì˜¤ íŒŒì¼ ì ‘ê·¼
3. **SQLite ë™ì‹œì„±**: ë‹¨ì¼ Writer ì œí•œ

### ìµœì í™” ê¸°íšŒ
1. **í´ë¦½ ìƒì„± í**: ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ì‹œìŠ¤í…œ
2. **CDN í™œìš©**: ì •ì  íŒŒì¼ ë°°í¬
3. **ë°ì´í„°ë² ì´ìŠ¤ ìƒ¤ë”©**: ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬

---

> **ğŸ“ ì´ ë¬¸ì„œëŠ” ì‹œìŠ¤í…œì˜ í•µì‹¬ ë¡œì§ê³¼ ì•„í‚¤í…ì²˜ë¥¼ ë‹¤ë£¹ë‹ˆë‹¤. ì‹¤ì œ êµ¬í˜„ ì‹œ ìµœì‹  ì½”ë“œë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.**
